\chapter{Technical Design}
\label{chap:technical}

This chapter in the thesis would have the technical design of the project.  It would contain the design details for the architecture of the solution, program flow, and the details of the components.

\section{Architectures in Unity(Introduction, discusses the component based nature of Unity)}

\section{Lobby/Main Menu}

\section{Ingame scene setup (Game managers and what not)}
\subsection{Ingame UI}

\section{Player architecture}
\subsection{Input}
\subsection{Field of View}
\subsection{Health and currency}
\subsection{Player Status}
\subsection{Docking}

\section{Modifiers architecture}
\subsection{Using scriptable objects for modifier data}

\section{Game modes}

\section{Docking Kit architecture}
\subsection{Connectivity between Ability, Docking and Docking Kit}
\subsection{Ability architecture, use of interfaces}

\section{Docking Kits}
\label{sec:dockingKits}
\subsection{Bomber Kit}
\subsection{Boomerang Kit}
The boomerang kit is a high speed, high damage kit with low health. The kit's abilities are primarily focused on augmenting the boomerangs that the player can throw. The boomerang itself has a small field of view circle around itself which allows the player to still see the boomerang if it has been thrown across a wall or other areas where vision is limited. 

\begin{figure}[tbph]  %t top, b bottom, p page | you can also use h to try to get the figure to appear at the current location
  \centering
  \includegraphics[width=.75\textwidth]{images/boomerangKitLineRenderer}
  \caption[Approximate travel path of the boomerang]{A screenshot from the game showing the approximate travel path of the boomerang when the ability button is held}
  \label{fig:boomerangLineRenderer}
\end{figure}

The primary ability of the boomerang kit is the boomerang throw. It uses cubic bezier curves to construct and display the approximate path that the boomerang will travel using a LineRenderer component. Figure~\ref{fig:boomerangLineRenderer} shows how the approximate path looks like for the local player using the kit. 
The bezier curvers are also used for interpolating the position of the boomerang as it is thrown by the player. The interpolation itself is handled using a timer variable that gets updated with Time.deltaTime per update loop. The timer variable is then used as input into an evaluation function used for controlling the speed of the animation and returns a smoothed version of its input. This output is then used as the input time for the bezier curve's interpolation. A more in-depth look at the interpolation of the boomerang throw can be found in section~\ref{sec:boomerangCurve}. 
    
There are also two additional boomerangs that are activated with the final ability in the kit. These have their own bezier curve control points and LineRenderers.
In order to perform the same operations on all boomerangs we have a array of structs containing the bezier control points and the stored positions of each boomerang. This allows us to modify the positions of all the bezier control points directly in the editor which makes it easy to control the shape of the curves.  

The second ability in the kit applies a root modifier to any enemy players within a certain range of the boomerang at the time of activation. It displays a range indicator for the local player whenever the ability is off cooldown making it easier to time the activation of the ability. Activating the ability will play a short ability animation around the boomerang on all clients and enables the collider component that checks for enemy players. The collider stays active for 0.5 seconds to make it a bit easier for the player using the ability to hit others as the boomerang moves at a fairly high speed. 
    
The next ability in the kit is a fairly simple ability that revolves around using a self applied modifier to control the state of its effects. Using the ability takes the field of view component of the boomerangs and quickly interpolates the radius of these to a higher value, giving the player a large circle of vision for a short duration. The additional vision is only something the local player can see while other players will see a circle indicator around the boomerang that showcases the new vision range. Once the duration of the modifier runs out the vision range quickly interpolates back to its default. 

The final ability of the boomerang kit is another self applied modifier that lasts for a few seconds and makes the next boomerang throw contain three boomerangs instead of one. This is the key ability of the kit that allows for a truly massive damage output given that the player is able to hit with all of the boomerangs. The self applied modifier is removed prematurely once a boomerang throw is made, but can also wear of naturally if the player avoids throwing any boomerangs during its duration. 

The additional boomerangs granted from this ability are also affected by the root and vision abilities, albeit with a lesser range. The boomerang throw script handles the interpolation of the two additional boomerangs while the script for this ability primarily manages the state of the buff. This includes self applying the modifier buff, managing the state of any extra visual elements and playing animations. 
    

\subsection{Brawler Kit}
The brawler kit is slow moving melee oriented kit, but has high health and multiple tools for dealing with enemies who fight at range. 

The first ability is a short cooldown slash with the brawler kit's axe. We are using OnTriggerStay instead of OnTriggerEnter as the collision callback for this ability. This is due to the fact that the animation for the slash is very quick and only lasts a few frames at its start position. Using OnTriggerEnter in this case would make the callback frequency too low at the start of the animation, essentially making it impossible to hit players nearby the start position of the axe. This happened because the first few frames would only trigger collision callbacks for the player's own overlapping collider instead of others. 
This issue is alleviated by using OnTriggerStay instead with a stored list of hit players. The list is reset after each swing and makes sure that any damage is only applied to each player once. 

The second ability in the kit is a self applied modifier that lasts for a certain duration, making the next axe slash deal increased damage and heal a certain percentage of the damage done. It works in a similar fashion to the final ability of the boomerang kit. The self applied modifier can wear of naturally or be removed after colliding with another player. Having the modifier active also changes the visuals of the axe to show that the ability has been used. 

The third ability is a self applied modifier that reflects the velocity of any projectiles that hits the player while active. This is handled using C\# interfaces. Any projectile that is reflectable needs to implement a IReflectable interface. This in turn allows the ability to check whether the interface exists on any colliding projectiles and ask them to reflect their velocity. The ability itself does not perform any reflection directly as this is what the projectiles implementing the interface have to contain.

\begin{figure}[tbph]  %t top, b bottom, p page | you can also use h to try to get the figure to appear at the current location
  \centering
  \includegraphics[width=.75\textwidth]{images/stunGrenade}
  \caption[Screenshot of the brawler kit's stun grenade]{A screenshot from the game showcasing the additional vision range granted from an exploded stun grenade}
  \label{fig:brawlerStunGrenade}
\end{figure}

The final ability makes the player throw a stun grenade that explodes after a short while, providing temporary vision for all players(see Figure~\ref{fig:brawlerStunGrenade}) and applying a stun modifier to anyone looking towards the explosion center. The grenade itself is a SpawnableObject and controls the application of modifiers, the temporary vision and any visual elements related to the grenade. The player on the other hand has a simple script that handles the spawning of the grenade. The grenade enables a large sphere collider on explosion which checks for any players within its range. A raycast is then used in conjunction with a dot product to check for players looking towards the center of the explosion. Players with obstacles between themselves and the explosion center will not get stunned as the raycast check will end up failing. 

\subsection{Marksman Kit}
\subsection{Sniper Kit}
\subsection{Tank Kit}

\subsection{Trapper Kit}
The Trapper Kit is a utility docking kit that focuses on using its three traps to provide various types of crowd control as well as being adequately capable of fighting enemies in close to mid range using the kit's flamethrower.  

The first ability in the kit is the flamethrower, a self applied modifier that activates a large sphere collider that checks for objects that it can burn. One of the limitations of working with Unity3D rather than Unity2D is that we don't have access to polygon colliders. Using polygon colliders would have made it possible to create a cone collider for this ability. We are instead using a large sphere collider for the flamethrower although its shape is not necessarily as fitting.
The collision callback checks for any enemy players and applies a burn modifier to these. It also checks for game objects with the IElement interface and applies a fire element to any such objects if found. This means that abilities from other kits that support elemental modifiers can be buffed by the flamethrower.

The three other abilities use traps deriving from a base Trap class. A shared TrapSpawner script is used to spawn each of the three traps by providing it with different prefabs per ability. 
The trap spawner script handles spawning its given trap prefab as well as updating the visuals of the docking kit to reflect that traps have been placed. Each trap has its own visual element on the docking kit that is modified to allow other players to know which traps the user currently has placed. Figure~\ref{fig:trapperKit} showcases these.
The trap spawner script contains a reference to the spawned trap while the spawned trap is provided with a reference back to its owner. This allows the trap to only stay visible for its owner as well as communicating back to its owner whenever it has been triggered. 

Acquiring the reference to the traps is handled by implementing the ISpawnableReferenceProvider interface. Only one trap of each type can be placed at a time so trying to replace a trap that already is placed destroys the old trap and places a new one at the player's current position.  

\begin{figure}[tbph]  %t top, b bottom, p page | you can also use h to try to get the figure to appear at the current location
  \centering
  \includegraphics[width=.75\textwidth]{images/TrapperKitWithTraps}
  \caption[The trapper kit with its three traps]{The trapper kit has three traps. Placing one trap fades the color of its associated visual element on the docking kit}
  \label{fig:trapperKit}
\end{figure}

The Trap base class handles generic functionality like changing the visual state of the trap to invisible for other players as well as playing animations whenever the trap is triggered. A virtual function is used to allow any children of the base class to provide custom behaviour as the trap is triggered. The base class also contains a list of players that triggered it to make sure that no modifiers are applied twice in the case that a player quickly moves in and out of the trap collider. 

The two first traps have fairly simple behaviour. Both have modifiers that they apply to the list of players who triggered the trap. The first applies a burn and slow modifier while the second applies a blind modifier. 

The third trap has more custom behaviour compared to the previous two. It pulls in any nearby enemy players after triggering and places a temporary wall around these players to "capture" them for a short duration. There are a lot of different visual elements like particle systems, animations and sprites that are enabled/disabled throughout the trap's lifecycle. 

Applying the force for pulling players into the trap is done using a TargetRpc function located in the main player script while a C\# coroutine is used to enable the walls after a short duration. More information on adding consistent force to both the server and clients can be found in section **PLACE REFERENCE HERE PLS**. 

\subsection{Support Kit}

\section{Shop Architecture}
- Single script IngameMenuHandler.cs handles interaction with the shop.
        - Loads all scriptable objects with item data. 
        - Adds these to a list that is sorted by price
        - Instantiatiates ShopInstance's for each scriptable object with the grid layout object as parent. 
        
        - Takes input for two buttons that lets it increment/decrement a highlighted id.
            - Limited to range (0, 4) so we cannot get any out of range errors.
        - The script then updates the shop interface with all of the information about the given ability/description using the id as a index to the scriptable object's list of descriptions.  

- PlayerInput handles opening/closing the shop
- One Shop Menu gameobject with different children and components for Visuals and Buttons
        - A purchase verification game object that appears when the player wants to purchase a kit
        - The left most panel is a game object containing a content size fitter and grid layout group. This means that any child gameobjects with a layout element component will be placed in a grid like fashion by its parent.
            - This is where we find the shopInstances
            
        - The right most panel displays information on the currently selected docking kit. 
            - Contains the information gotten from the shopInstance.itemData scriptable object. 
            - Has three text boxes: One for the name, one for additional stats like: cooldown, speed, etc and a desciption box for describing what the ability does or what the docking kit is about. 
            - Currently viewed description is highlighted by a dark overlay in the logo panel. 
            - The player can navigate through the descriptions using the displayed buttons.

- ShopItemInstance(Prefab)
    - One instance contains a scriptable object with shop data.
    - Instantiated and initialised by the IngameMenuHandler
    - Attached to a gameobject containing a couple of UI elements and visuals that allow it to display a icon for the shop item and its price. 
    - Also contains a OnClick() button callback that is called whenever the player presses the shop item.
        - Simply asks the ingameMenuHandler to display the verification prompt

\subsection{Using scriptable objects for shop items}
- Easy to use interface for developers.(INCLUDE IMAGE) Can simply go to the correct resource folder, right click and choose "new shop item"
- ShopItemData is a scriptable object containing the name of the shop item, the sprite that will be displayed in the shop, the prefab for the docking kit that this shop item contains, its price and the enum ID of the docking kit needed for various functionality like docking/undocking the player on purchase. 
- Also contains a list that is 5 elements long containing DockingKitDescriptions. One for general docking kit information and 4 for the abilities. 
- The description struct contains the icon that will be used by the UI to represent the highlighted element, the name of the ability/kit and a string containing the description.
- The menu handler will take care of the rest by instantiating all the ShopItemInstances.

\section{Standard Game Flow}
