\chapter{Technical Design}
\label{chap:technical}

This chapter in the thesis would have the technical design of the project.  It would contain the design details for the architecture of the solution, program flow, and the details of the components.

\section{Architectures in Unity(Introduction, discusses the component based nature of Unity)}

\section{Lobby/Main Menu}

\section{Ingame scene setup (Game managers and what not)}
\subsection{Ingame UI}

\section{Player architecture}
\subsection{Input}
\subsection{Field of View}
\subsection{Health and currency}
\subsection{Player Status}
\subsection{Docking}

\section{Modifiers architecture}
\subsection{Using scriptable objects for modifier data}

\section{Game modes}

\section{Docking Kit architecture}
\subsection{Connectivity between Ability, Docking and Docking Kit}
\subsection{Ability architecture, use of interfaces}

\section{Docking Kits}
\subsection{Bomber Kit}
\subsection{Boomerang Kit}
- Boomerang throw:
    - Holding the ability button down displays a approximate travel path, releasing throws the boomerang
    - Uses a cubic bezier curve to construct and display the approximate path using a linerenderer. The bezier curve is also used for interpolating the boomerang.
    - Interpolation is handled by using a simple timer variable that gets incremented per update. This variable is then put into the evaluation function of the animation curve that controls the speed of the boomerang. This output is then used as the input parameter for the interpolation. 
    
    - There are also two additional boomerangs that are activated with the final ability in the kit. These have their own bezier curve control points and linerenderers.
    - To perform the same operations on all boomerangs we have a array of structs containing the bezier control points and the stored positions of each boomerang. 
    
    - The main boomerang supports elemental modifiers so it is capable of transferring burns, electric stuns, etc using the elementalModifiers class. 
    
- Boomerang vision:
    - A fairly simple ability that works as a self applied modifier. 
    - Each boomerang has a FieldOfView script like like the ones the players use. Using this ability activates the FieldOfView component on each active boomerang and provides a large circle around each boomerang that allows for additional vision. The additional vision is only for the local player while other players will simply see a circle indicator showcasing the vision range that the player using the kit now has. Once the duration runs out the radius of the vision circle quickly interpolates back to 0 and disables the component again.

- Boomerang root:
    - Ability that roots any enemy players within a certain range of the boomerang.
    - Displays a range indicator around the boomerang for the local player whenever the ability is off cooldown.
    
    - Activating the ability will play a short animation on all clients to showcase that it has been used. All enemy players within the range will get a root modifier applied. 
    
- Initiate multirangs:
    - The final ability of the boomerang kit is a self applied modifier that lasts for a few seconds and makes the next boomerang throw contain three boomerangs instead of just one. Throwing the boomerangs before the modifier duration wears off removes it prematurely. 
    - Having the modifier active synchronises an animation on all clients displaying the two additional boomerangs on the player using the kit.
    - The root and vision abilities also work with the two additional boomerangs. 
    
    - The boomerang throw script handles the interpolation of the two additional boomerangs while this ability manages the state of the buff and the additional visuals. 
    

\subsection{Brawler Kit}
 - Basic Slash:
    - Simple short cooldown ability that makes the player slash with the axe. 
    - Supports elemental modifiers
    - Uses OnTriggerStay instead of OnTriggerEnter for dealing out damage. 
        - Stores a list of hit players that gets reset after the swing is over. This prevents being able to hit one player multiple times in one swing. 
        
        - The main reason for using OnTriggerStay over OnTriggerEnter is that by default OnTriggerEnter will only trigger for the collider of the player using the ability in the first few frames as they overlap. Due to the very quick animation this means that hitting other players close to the start position of the animation is impossible. This is not an issue when using OnTriggerStay as these callbacks happen more frequently, providing a more consistent player experience.

 - Lifesteal buff:
    - Self applied modifier that lasts for a certain duration and makes the next colliding axe slash deal increased damage and heal a certain percentage of the damage done back. Works in a similar fashion to the multirang ability of the boomerang kit. The modifier can wear off naturally through its timer or prematurely by being removed after colliding with another player. 
    
    - Having the modifier active makes the ability script modify the visuals of the axe. 
    
 - Projectile reflect:
    - Self applied modifier that puts a temporary shield around the player for a short duration that reflects any colliding projectiles using the IReflectable interface.
    
    - Does not perform the reflection code itself, that is the job of the projectile implementing the IReflectable interface. 
    
 - Flash grenade:
    - Throws a flash grenade that explodes after a short while, giving a temporary circle of vision and applied a stun modifier to any players looking towards the explosion. 
    - Uses two scripts, the ability script handles spawning of the flash grenade while the other script is attached to the grenade itself and handles the logic related to its explosion.
    
    - The grenade spawner script is very simple, it simply asks docking to spawn the prefab for the flash grenade. 
    
    - The grenade itself explodes after its set duration, the explosion activates its associated animations, colliders and other visuals.
    - Has a collider that is the same size of the temporary vision range. The OnTriggerEnter callback checks for players and uses a raycast to make sure that the player is within range and that there are no obstructions between the player and the explosion. A dot product is then calculated between the player's facing direction and a vector between the player's and the explosion's position to check if the player is facing towards the bomb. A stun modifier is then applied if these requirements are fulfilled. 

\subsection{Marksman Kit}
\subsection{Sniper Kit}
\subsection{Tank Kit}

\subsection{Trapper Kit}
- Flamethrower:
    - Self applied modifier that controls the state of the flamethrower
    - Pressing the ability button activates the modifier for a set duration, toggling the flamethrower to active.
    
    - Uses a large sphere collider when checking for objects to burn.
            - Makes sure that it hits players and not itself/parent player
            - Applied a burn modifier to players it hits
            - Also checks if whatever it hits has the IElement interface.
                - If it does, uses ApplyElement(Fire)
            - This means that the flamethrower is capable of buffing applicable abilities of other players. 

- Trap Spawner
    - All the traps share a trap spawner script in their ability slot, each with its own trap prefab and a reference back to the spawned trap for syncing visuals and other things. 
    
    - Each trap also has an associated visual element on the docking kit, the alpha of this element is faded out as the trap is placed and faded back in once the trap is triggered. 
        - Allows other players to see if the traps are placed or not by looking at the player using the kit.
        
    - Uses the ISpawnableReferenceProvider interface to acquire its reference to the placed trap. 
    
    - Can only place one of each trap at any given time. Replacing an existing trap simply destroys the old and places a new one at the current position. 

- Trap base class:
    - All traps derive from a trap base class that handles the changes in visual state and playing animations when the trap is triggered. 
    - The base class has a virtual function HandleTrigger() which allows the deriving classes to perform their own custom behaviour as the trap is triggered. 
    
    - Contains a reference to its owner and a list of players that it uses to make sure that any modifiers or additional effects only are applied once in the case that a player quickly moves in and out of the trap's range. 
    - The reference back to the owner is used so that the trap can tell its owner that is has been destroyed, allowing the owner to change visually to reflect the fact that the trap is no longer placed.
    
    - Destroys itself after a given duration. 
    

- Slow and Burn trap:
    - Uses a script that simply applies a burn and slow modifier in its HandleTrigger() function

- Blind trap:
    - Works like the Slow and Burn trap script, simply applies a blind modifier in its HandleTrigger()

- Capture trap:
    - A bit more complex trap. It sucks in any nearby enemy players after its been triggered and places a temporary wall around the players who were sucked in, essentially "capturing" them for a short duration
    
    - Contains a lot of different visual elements that are enabled/disabled/animated as the trap's lifecycle goes on. 
    
    - Uses Player.TargetAddForce() to continuously apply force on all players within the trap range for a given duration before enabling the walls around it. 
    
    - Uses a Coroutine to spawn in the walls after a short duration of being pulled in.
        - Starts pulling as its triggered. The Coroutine then disables the pull and sets up the walls once it continues. 

\subsection{Support Kit}

\section{Shop Architecture}
\todo {How detailed should a section like this be?}
- Single script IngameMenuHandler.cs handles interaction with the shop.
        - Loads all scriptable objects with item data. 
        - Adds these to a list that is sorted by price
        - Instantiatiates ShopInstance's for each scriptable object with the grid layout object as parent. 
        
        - Takes input for two buttons that lets it increment/decrement a highlighted id.
            - Limited to range (0, 4) so we cannot get any out of range errors.
        - The script then updates the shop interface with all of the information about the given ability/description using the id as a index to the scriptable object's list of descriptions.  

- PlayerInput handles opening/closing the shop
- One Shop Menu gameobject with different children and components for Visuals and Buttons
        - A purchase verification game object that appears when the player wants to purchase a kit
        - The left most panel is a game object containing a content size fitter and grid layout group. This means that any child gameobjects with a layout element component will be placed in a grid like fashion by its parent.
            - This is where we find the shopInstances
            
        - The right most panel displays information on the currently selected docking kit. 
            - Contains the information gotten from the shopInstance.itemData scriptable object. 
            - Has three text boxes: One for the name, one for additional stats like: cooldown, speed, etc and a desciption box for describing what the ability does or what the docking kit is about. 
            - Currently viewed description is highlighted by a dark overlay in the logo panel. 
            - The player can navigate through the descriptions using the displayed buttons.

- ShopItemInstance(Prefab)
    - One instance contains a scriptable object with shop data.
    - Instantiated and initialised by the IngameMenuHandler
    - Attached to a gameobject containing a couple of UI elements and visuals that allow it to display a icon for the shop item and its price. 
    - Also contains a OnClick() button callback that is called whenever the player presses the shop item.
        - Simply asks the ingameMenuHandler to display the verification prompt

\subsection{Using scriptable objects for shop items}
- Easy to use interface for developers. Can simply go to the correct resource folder, right click and choose "new shop item"
- ShopItemData is a scriptable object containing the name of the shop item, the sprite that will be displayed in the shop, the prefab for the docking kit that this shop item contains, its price and the enum ID of the docking kit needed for various functionality like docking/undocking the player on purchase. 
- Also contains a list that is 5 elements long containing DockingKitDescriptions. One for general docking kit information and 4 for the abilities. 
- The description struct contains the icon that will be used by the UI to represent the highlighted element, the name of the ability/kit and a string containing the description.
- The menu handler will take care of the rest by instantiating all the ShopItemInstances.

\section{Standard Game Flow}
